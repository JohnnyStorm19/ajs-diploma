{"version":3,"file":"main.js","mappings":"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","sources":["webpack://js-advanced-diploma/./src/js/Modules/utils.js","webpack://js-advanced-diploma/./src/js/Services/GamePlay.js","webpack://js-advanced-diploma/./src/js/Modules/themes.js","webpack://js-advanced-diploma/./src/js/Modules/GameState.js","webpack://js-advanced-diploma/./src/js/characters/Character.js","webpack://js-advanced-diploma/./src/js/Modules/PositionedCharacter.js","webpack://js-advanced-diploma/./src/js/Modules/generators.js","webpack://js-advanced-diploma/./src/js/Modules/cursors.js","webpack://js-advanced-diploma/./src/js/Modules/calculateCellsForMove.js","webpack://js-advanced-diploma/./src/js/Modules/calculateOccupiedCells.js","webpack://js-advanced-diploma/./src/js/Modules/calculateCellsForAttack.js","webpack://js-advanced-diploma/./src/js/Modules/reloadState.js","webpack://js-advanced-diploma/./src/js/Modules/checkActivePlayer.js","webpack://js-advanced-diploma/./src/js/Modules/gameOver.js","webpack://js-advanced-diploma/./src/js/Modules/checkHealth.js","webpack://js-advanced-diploma/./src/js/Modules/botAttack.js","webpack://js-advanced-diploma/./src/js/Modules/calculateCellForAction.js","webpack://js-advanced-diploma/./src/js/Modules/botMove.js","webpack://js-advanced-diploma/./src/js/Services/BotActionLogic.js","webpack://js-advanced-diploma/./src/js/Services/GameStateService.js","webpack://js-advanced-diploma/./src/js/characters/CharacterLoaded.js","webpack://js-advanced-diploma/./src/js/characters/Bowman.js","webpack://js-advanced-diploma/./src/js/characters/Magician.js","webpack://js-advanced-diploma/./src/js/characters/Swordsman.js","webpack://js-advanced-diploma/./src/js/characters/Undead.js","webpack://js-advanced-diploma/./src/js/characters/Vampire.js","webpack://js-advanced-diploma/./src/js/characters/Daemon.js","webpack://js-advanced-diploma/./src/js/app.js","webpack://js-advanced-diploma/./src/js/Services/GameController.js"],"sourcesContent":["/**\n * @todo\n * @param index - индекс поля\n * @param boardSize - размер квадратного поля (в длину или ширину)\n * @returns строка - тип ячейки на поле:\n *\n * top-left\n * top-right\n * top\n * bottom-left\n * bottom-right\n * bottom\n * right\n * left\n * center\n *\n * @example\n * ```js\n * calcTileType(0, 8); // 'top-left'\n * calcTileType(1, 8); // 'top'\n * calcTileType(63, 8); // 'bottom-right'\n * calcTileType(7, 7); // 'left'\n * ```\n * */\n// Задача #1.2 - отрисовываем границы\nexport function calcTileType(index, boardSize) {\n  // TODO: ваш код будет тут\n  const boardLength = boardSize ** 2;\n  if (index === 0) {\n    return 'top-left';\n  }\n  if (index === boardSize - 1) {\n    return 'top-right';\n  }\n  if (index === boardLength - 1) {\n    return 'bottom-right';\n  }\n  if (index === boardLength - boardSize) {\n    return 'bottom-left';\n  }\n\n  const row = Math.ceil(index / boardSize);\n  if (Number.isInteger(index / boardSize)) {\n    return 'left';\n  }\n  if (Number.isInteger((index + 1) / boardSize)) {\n    return 'right';\n  }\n  if (row === 1) {\n    return 'top';\n  }\n  if (row === boardSize) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nexport function calcHealthLevel(health) {\n  if (health < 15) {\n    return 'critical';\n  }\n\n  if (health < 50) {\n    return 'normal';\n  }\n\n  return 'high';\n}\n","/* eslint-disable no-param-reassign */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-alert */\nimport { calcHealthLevel, calcTileType } from '../Modules/utils';\n\nexport default class GamePlay {\n  constructor() {\n    this.boardSize = 8;\n    this.container = null;\n    this.boardEl = null;\n    this.cells = [];\n    this.cellClickListeners = [];\n    this.cellEnterListeners = [];\n    this.cellLeaveListeners = [];\n    this.newGameListeners = [];\n    this.saveGameListeners = [];\n    this.loadGameListeners = [];\n  }\n\n  bindToDOM(container) {\n    if (!(container instanceof HTMLElement)) {\n      throw new Error('container is not HTMLElement');\n    }\n    this.container = container;\n  }\n\n  /**\n   * Draws boardEl with specific theme\n   *\n   * @param theme\n   */\n  drawUi(theme) {\n    this.checkBinding();\n\n    this.container.innerHTML = `\n      <div class=\"controls\">\n        <button data-id=\"action-restart\" class=\"btn\">New Game</button>\n        <button data-id=\"action-save\" class=\"btn\">Save Game</button>\n        <button data-id=\"action-load\" class=\"btn\">Load Game</button>\n      </div>\n      <div class=\"board-container\">\n        <div data-id=\"board\" class=\"board\"></div>\n      </div>\n      <div class=\"console\"></div>\n    `;\n\n    this.newGameEl = this.container.querySelector('[data-id=action-restart]');\n    this.saveGameEl = this.container.querySelector('[data-id=action-save]');\n    this.loadGameEl = this.container.querySelector('[data-id=action-load]');\n\n    this.newGameEl.addEventListener('click', (event) => this.onNewGameClick(event));\n    this.saveGameEl.addEventListener('click', (event) => this.onSaveGameClick(event));\n    this.loadGameEl.addEventListener('click', (event) => this.onLoadGameClick(event));\n\n    this.newGameEl.addEventListener('mouseenter', () => this.onEnterControllerBtn(this.newGameEl));\n    this.saveGameEl.addEventListener('mouseenter', () => this.onEnterControllerBtn(this.saveGameEl));\n    this.loadGameEl.addEventListener('mouseenter', () => this.onEnterControllerBtn(this.loadGameEl));\n\n    this.boardEl = this.container.querySelector('[data-id=board]');\n\n    this.boardEl.classList.add(theme);\n    for (let i = 0; i < this.boardSize ** 2; i += 1) {\n      const cellEl = document.createElement('div');\n      cellEl.classList.add('cell', 'map-tile', `map-tile-${calcTileType(i, this.boardSize)}`);\n      cellEl.addEventListener('mouseenter', (event) => this.onCellEnter(event));\n      cellEl.addEventListener('mouseleave', (event) => this.onCellLeave(event));\n      cellEl.addEventListener('click', (event) => this.onCellClick(event));\n      this.boardEl.appendChild(cellEl);\n    }\n\n    this.cells = Array.from(this.boardEl.children);\n  }\n\n  /**\n   * Add callback to mouse enter event for controller block buttons\n   *\n   * @param element - current element (newGameEl / loadGameEl / saveGameEl)\n   */\n  onEnterControllerBtn(element) {\n    element.style.cursor = 'pointer';\n  }\n\n  /**\n   * Draws positions (with chars) on boardEl\n   *\n   * @param positions array of PositionedCharacter objects\n   */\n  redrawPositions(positions) {\n    for (const cell of this.cells) {\n      cell.innerHTML = '';\n    }\n\n    for (const position of positions) {\n      const cellEl = this.boardEl.children[position.position];\n      const charEl = document.createElement('div');\n      charEl.classList.add('character', position.character.type);\n\n      const healthEl = document.createElement('div');\n      healthEl.classList.add('health-level');\n\n      const healthIndicatorEl = document.createElement('div');\n      healthIndicatorEl.classList.add('health-level-indicator', `health-level-indicator-${calcHealthLevel(position.character.health)}`);\n      healthIndicatorEl.style.width = `${position.character.health}%`;\n      healthEl.appendChild(healthIndicatorEl);\n\n      charEl.appendChild(healthEl);\n      cellEl.appendChild(charEl);\n    }\n  }\n\n  /**\n   * Add listener to mouse enter for cell\n   *\n   * @param callback\n   */\n  addCellEnterListener(callback) {\n    this.cellEnterListeners.push(callback);\n  }\n\n  /**\n   * Add listener to mouse leave for cell\n   *\n   * @param callback\n   */\n  addCellLeaveListener(callback) {\n    this.cellLeaveListeners.push(callback);\n  }\n\n  /**\n   * Add listener to mouse click for cell\n   *\n   * @param callback\n   */\n  addCellClickListener(callback) {\n    this.cellClickListeners.push(callback);\n  }\n\n  /**\n   * Add listener to \"New Game\" button click\n   *\n   * @param callback\n   */\n  addNewGameListener(callback) {\n    this.newGameListeners.push(callback);\n  }\n\n  /**\n   * Add listener to \"Save Game\" button click\n   *\n   * @param callback\n   */\n  addSaveGameListener(callback) {\n    this.saveGameListeners.push(callback);\n  }\n\n  /**\n   * Add listener to \"Load Game\" button click\n   *\n   * @param callback\n   */\n  addLoadGameListener(callback) {\n    this.loadGameListeners.push(callback);\n  }\n\n  onCellEnter(event) {\n    event.preventDefault();\n    const index = this.cells.indexOf(event.currentTarget);\n    this.cellEnterListeners.forEach((o) => o.call(null, index));\n  }\n\n  onCellLeave(event) {\n    event.preventDefault();\n    const index = this.cells.indexOf(event.currentTarget);\n    this.cellLeaveListeners.forEach((o) => o.call(null, index));\n  }\n\n  onCellClick(event) {\n    const index = this.cells.indexOf(event.currentTarget);\n    this.cellClickListeners.forEach((o) => o.call(null, index));\n  }\n\n  onNewGameClick(event) {\n    event.preventDefault();\n    this.newGameListeners.forEach((o) => o.call(null));\n  }\n\n  onSaveGameClick(event) {\n    event.preventDefault();\n    this.saveGameListeners.forEach((o) => o.call(null));\n  }\n\n  onLoadGameClick(event) {\n    event.preventDefault();\n    this.loadGameListeners.forEach((o) => o.call(null));\n  }\n\n  static showError(message) {\n    alert(message);\n  }\n\n  static showMessage(message) {\n    alert(message);\n  }\n\n  selectCell(index, color = 'yellow') {\n    this.deselectCell(index);\n    this.cells[index].classList.add('selected', `selected-${color}`);\n  }\n\n  deselectCell(index) {\n    const cell = this.cells[index];\n    cell.classList.remove(...Array.from(cell.classList)\n      .filter((o) => o.startsWith('selected')));\n  }\n\n  showCellTooltip(message, index) {\n    this.cells[index].title = message;\n  }\n\n  hideCellTooltip(index) {\n    this.cells[index].title = '';\n  }\n\n  showDamage(index, damage) {\n    return new Promise((resolve) => {\n      const cell = this.cells[index];\n      const damageEl = document.createElement('span');\n      damageEl.textContent = damage;\n      damageEl.classList.add('damage');\n      cell.appendChild(damageEl);\n\n      damageEl.addEventListener('animationend', () => {\n        cell.removeChild(damageEl);\n        resolve();\n      });\n    });\n  }\n\n  setCursor(cursor) {\n    this.boardEl.style.cursor = cursor;\n  }\n\n  checkBinding() {\n    if (this.container === null) {\n      throw new Error('GamePlay not bind to DOM');\n    }\n  }\n}\n","const themes = {\n  prairie: 'prairie',\n  desert: 'desert',\n  arctic: 'arctic',\n  mountain: 'mountain',\n};\n\nexport default themes;\n","/* eslint-disable class-methods-use-this */\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-len */\nimport themes from './themes';\n\nexport default class GameState {\n  constructor() {\n    this.selected = {\n      isSelected: false, position: null, charType: null, charTeam: null,\n    }; // храним состояние выбранного персонажа, его индекс и тип\n    this.team = {\n      playerTypes: ['magician', 'swordsman', 'bowman'],\n      botTypes: ['undead', 'vampire', 'daemon'],\n      playerTeam: null, // сгенерированная команда игрока\n      botTeam: null, // сгенерированная команда бота\n    };\n    this.currentLevel = 1;\n    this.currentPlayer = 'player'; // текущий ход\n    this.levels = {\n      1: themes.prairie,\n      2: themes.desert,\n      3: themes.arctic,\n      4: themes.mountain,\n    };\n    this.mouseEnter = { // записывается индекс ячейки атаки/движения при наведении\n      attack: null,\n      move: null,\n    }; // индекс ячейки при наведении (cellEnter)\n    this.maxLevelChar = 2;\n    this.maxCharsCount = 2;\n    this.allowedSteps = { // доступные \"шаги\"\n      swordsman: 4,\n      undead: 4,\n      bowman: 2,\n      vampire: 2,\n      magician: 1,\n      daemon: 1,\n    };\n    this.allowedForAttack = { // радиус атаки\n      swordsman: 1,\n      undead: 1,\n      bowman: 2,\n      vampire: 2,\n      magician: 4,\n      daemon: 4,\n    };\n    this.borders = { // границы всего поля\n      left: [],\n      right: [],\n    };\n  }\n\n  isUserCharacter(char) {\n    return this.team.playerTypes.includes(char.type);\n  }\n\n  selectChar(gamePlay, gameState, index, type, team) {\n    if (gameState.selected.isSelected) {\n      gamePlay.deselectCell(gameState.selected.position);\n    }\n    gamePlay.selectCell(index);\n    gameState.selected = {\n      isSelected: true, position: index, charType: type, charTeam: team,\n    };\n  }\n\n  // static from(object) {\n  //   // TODO: create object\n  //   this.currentState = object;\n  //   return null;\n  // }\n}\n","/* eslint-disable no-underscore-dangle */\n/* eslint-disable no-mixed-operators */\n/* eslint-disable max-len */\n/**\n * Базовый класс, от которого наследуются классы персонажей\n * @property level - уровень персонажа, от 1 до 4\n * @property attack - показатель атаки\n * @property defence - показатель защиты\n * @property health - здоровье персонажа\n * @property type - строка с одним из допустимых значений:\n * swordsman\n * bowman\n * magician\n * daemon\n * undead\n * vampire\n */\nexport default class Character {\n  constructor(level, type = 'generic') {\n    if (new.target.name === 'Character') {\n      throw new Error('Base class cannot be the instance');\n    }\n    this.level = level;\n    this.attack = 0;\n    this.defence = 0;\n    this.health = 100;\n    this._type = type;\n    // TODO: выбросите исключение, если кто-то использует \"new Character()\"\n  }\n\n  levelUp() {\n    const attackAfter = Math.max(this.attack, this.attack * (80 + this.health) / 100);\n    const defenceAfter = Math.max(this.defence, this.defence * (80 + this.health) / 100);\n    this.attack = Math.round(attackAfter);\n    this.defence = Math.round(defenceAfter);\n\n    if (this.health !== 100) {\n      this.health += 80;\n    }\n    if (this.health > 100) this.health = 100;\n    this.level += 1;\n  }\n}\n","import Character from '../characters/Character';\n\nexport default class PositionedCharacter {\n  constructor(character, position) {\n    if (!(character instanceof Character)) {\n      throw new Error('character must be instance of Character or its children');\n    }\n\n    if (typeof position !== 'number') {\n      throw new Error('position must be a number');\n    }\n\n    this.character = character;\n    this.position = position;\n  }\n}\n","/* eslint-disable no-console */\nimport GamePlay from '../Services/GamePlay';\nimport PositionedCharacter from './PositionedCharacter';\n\n/**\n * Формирует экземпляр персонажа из массива allowedTypes со\n * случайным уровнем от 1 до maxLevel\n *\n * @param allowedTypes массив классов\n * @param maxLevel максимальный возможный уровень персонажа\n * @returns генератор, который при каждом вызове\n * возвращает новый экземпляр класса персонажа\n *\n */\nexport function* characterGenerator(allowedTypes, maxLevel) {\n  // TODO: write logic here\n  const randomCharType = Math.floor(Math.random() * allowedTypes.length);\n  const randomLevel = Math.floor(Math.random() * maxLevel) + 1;\n  const char = new allowedTypes[randomCharType](1);\n  let count = randomLevel - 1;\n  while (count > 0) {\n    char.levelUp();\n    console.log('level up!');\n    count -= 1;\n  }\n  yield char;\n}\n\n/**\n * Формирует массив персонажей на основе characterGenerator\n * @param allowedTypes массив классов\n * @param maxLevel максимальный возможный уровень персонажа\n * @param characterCount количество персонажей, которое нужно сформировать\n * @returns экземпляр Team, хранящий экземпляры персонажей.\n * Количество персонажей в команде - characterCount\n * */\nexport function generateTeam(allowedTypes, maxLevel, characterCount) {\n  // TODO: write logic here\n  const res = [];\n  for (let i = 0; i < characterCount; i += 1) {\n    res.push(characterGenerator(allowedTypes, maxLevel).next().value);\n  }\n  return res;\n}\n\n/**\n * Формирует позицию (число) в зависисмости от команды\n * @param teamSide для какой команды генерировать позицию\n * @returns возвращает позицию (число) в зависимости от команды\n */\n\nexport function generatePosition(teamSide) {\n  const { boardSize } = new GamePlay();\n  const positions = [];\n  const start = teamSide === 'player' ? 0 : boardSize - 2;\n\n  for (let i = start; i < boardSize ** 2; i += boardSize) {\n    positions.push(i, i + 1);\n  }\n  return positions[Math.floor(Math.random() * positions.length)];\n}\n\n/**\n * Формирует массив объектов класса PositionedCharacter для позиционирования\n * @param teamSide для какой команды генерировать позицию\n * @param charArr массив из типов персонажей\n * @param maxLevel максимальный уровень для сгенерированных персонажей\n * @param characterCount количество персонажей в каждой из команд\n * @returns возвращает массив объектов класса PositionedCharacter\n */\n\nexport function generatePositionedCharacter(teamSide, charsArr, maxLevel, characterCount) {\n  const team = generateTeam(charsArr, maxLevel, characterCount);\n  const positionArr = [];\n  const redrawArr = [];\n\n  team.forEach((char, index) => {\n    // if (char.level > 1) {\n    //   let count = char.level - 1;\n    //   while (count > 0) {\n    //     char.levelUp();\n    //     console.log('level up!')\n    //     count -= 1;\n    //   }\n    // }\n    let position = generatePosition(teamSide);\n    const isThere = positionArr.includes(position);\n    while (isThere) {\n      position = generatePosition(teamSide);\n    }\n    positionArr.push(position);\n    redrawArr.push(new PositionedCharacter(char, positionArr[index]));\n  });\n  return redrawArr;\n}\n","const cursors = {\n  auto: 'auto',\n  pointer: 'pointer',\n  crosshair: 'crosshair',\n  notallowed: 'not-allowed',\n};\n\nexport default cursors;\n","import calculateOccupiedCells from './calculateOccupiedCells';\n\n/* eslint-disable max-len */\nexport default function calculateCellsForMove(gamePlay, gameState, selectedIndex, charTypeMoveNumber, leftBorder, rightBorder) {\n  const { boardSize } = gamePlay;\n  const occupiedCells = calculateOccupiedCells(gameState.team.botTeam, gameState.team.playerTeam);\n  const cellsForActions = [];\n  const startCell = 0;\n  const endCell = boardSize ** 2 - 1;\n  let steps = charTypeMoveNumber;\n  const moves = {\n    up: selectedIndex,\n    down: selectedIndex,\n    left: selectedIndex,\n    right: selectedIndex,\n    leftUpDiagonal: selectedIndex,\n    rightUpDiagonal: selectedIndex,\n    leftDownDiagonal: selectedIndex,\n    rightDownDiagonal: selectedIndex,\n  };\n  while (steps > 0) {\n    // допустимые клетки для верха\n    moves.up -= boardSize;\n    if (moves.up >= startCell && !occupiedCells.includes(moves.up)) {\n      cellsForActions.push(moves.up);\n    }\n    // допустимые клетки для низа\n    moves.down += boardSize;\n    if (moves.down <= endCell && !occupiedCells.includes(moves.down)) {\n      cellsForActions.push(moves.down);\n    }\n    // допустимые клетки слева\n    if (!leftBorder.includes(moves.left)) {\n      moves.left -= 1;\n      if (moves.left >= startCell && !occupiedCells.includes(moves.left)) {\n        cellsForActions.push(moves.left);\n      }\n    }\n    // допустимые клетки справа\n    if (!rightBorder.includes(moves.right)) {\n      moves.right += 1;\n      if (moves.right <= endCell && !occupiedCells.includes(moves.right)) {\n        cellsForActions.push(moves.right);\n      }\n    }\n    // допустимые клетки левой верхней диагонали\n    if (!leftBorder.includes(moves.leftUpDiagonal)) {\n      moves.leftUpDiagonal -= (boardSize + 1);\n      if (moves.leftUpDiagonal >= startCell && !occupiedCells.includes(moves.leftUpDiagonal)) {\n        cellsForActions.push(moves.leftUpDiagonal);\n      }\n    }\n    // допустимые клетки правой верхней диагонали\n    if (!rightBorder.includes(moves.rightUpDiagonal)) {\n      moves.rightUpDiagonal -= (boardSize - 1);\n      if (moves.rightUpDiagonal >= startCell && !occupiedCells.includes(moves.rightUpDiagonal)) {\n        cellsForActions.push(moves.rightUpDiagonal);\n      }\n    }\n    // допустимые клетки левой нижней диагонали\n    if (!leftBorder.includes(moves.leftDownDiagonal)) {\n      moves.leftDownDiagonal += (boardSize - 1);\n      if (moves.leftDownDiagonal <= endCell && !occupiedCells.includes(moves.leftDownDiagonal)) {\n        cellsForActions.push(moves.leftDownDiagonal);\n      }\n    }\n    // допустимые клетки правой нижней диагонали\n    if (!rightBorder.includes(moves.rightDownDiagonal)) {\n      moves.rightDownDiagonal += (boardSize + 1);\n      if (moves.rightDownDiagonal <= endCell && !occupiedCells.includes(moves.rightDownDiagonal)) {\n        cellsForActions.push(moves.rightDownDiagonal);\n      }\n    }\n    steps -= 1;\n  }\n  return cellsForActions;\n}\n","export default function calculateOccupiedCells(botTeam, playerTeam) {\n  const botCells = [];\n  const playerCells = [];\n  botTeam.forEach((obj) => botCells.push(obj.position));\n  playerTeam.forEach((obj) => playerCells.push(obj.position));\n  return [...botCells, ...playerCells];\n}\n","/* eslint-disable max-len */\nexport default function calculateCellsForAttack(gamePlay, selectedIndex, charTypeAttackNumber) {\n  const { boardSize } = gamePlay;\n  const cellsForActions = [];\n  const startCell = 0;\n  const endCell = boardSize ** 2 - 1;\n  const midCol = selectedIndex % boardSize; // столбец выбранного персонажа\n  let leftCol = midCol - charTypeAttackNumber; // левая граница\n  let rightCol = midCol + charTypeAttackNumber; // правая граница\n\n  if (leftCol < 0) leftCol = 0;\n  if (rightCol > (boardSize - 1)) rightCol = boardSize - 1;\n\n  let min = selectedIndex - charTypeAttackNumber - boardSize * charTypeAttackNumber; // минимальная клетка для атаки\n  if (min <= startCell) {\n    min = startCell;\n  }\n  let max = selectedIndex + charTypeAttackNumber + boardSize * charTypeAttackNumber; // максимальная клетка для атаки\n  if (max >= endCell) {\n    max = endCell;\n  }\n  for (let i = min; i <= max; i += 1) {\n    if (i % boardSize >= leftCol && i % boardSize <= rightCol && i !== selectedIndex) {\n      cellsForActions.push(i);\n    }\n  }\n  return cellsForActions;\n}\n","/* eslint-disable no-param-reassign */\nexport default function reloadState(state) {\n  state.team.botTeam = [];\n  state.team.playerTeam = [];\n  state.selected = {\n    isSelected: false, position: null, charType: null, charTeam: null,\n  };\n  state.currentLevel = 1;\n  state.mouseEnter = { // записывается индекс ячейки атаки/движения при наведении\n    attack: null,\n    move: null,\n  };\n  state.maxLevelChar = 2;\n  state.borders = { // границы всего поля\n    left: [],\n    right: [],\n  };\n}\n","/* eslint-disable no-console */\nimport { gameOver } from './gameOver';\n\n/* eslint-disable no-param-reassign */\nexport default function checkActivePlayer(state, gameController, gamePlay) {\n  if (state.team.playerTeam.length === 0) {\n    gameOver(state);\n  }\n  if (state.mouseEnter.move != null) {\n    gamePlay.deselectCell(state.mouseEnter.move);\n  }\n  state.selected = {\n    isSelected: false, position: null, charType: null, charTeam: null,\n  };\n  if (state.currentPlayer === 'bot') {\n    setTimeout(() => {\n      gameController.botAction(state.team.botTeam);\n    }, 3000);\n  }\n}\n","import GamePlay from '../Services/GamePlay';\nimport reloadState from './reloadState';\n\n/* eslint-disable no-param-reassign */\nexport function gameOver(state) {\n  state.currentPlayer = 'bot'; // тем самым блокирую нажатия и наведение на клетку\n  GamePlay.showMessage('Персонажи игрока повержены!');\n  GamePlay.showMessage('Если хотите испытать себя вновь начните новую игру (New Game)');\n}\n\nexport function winGame(state) {\n  state.currentPlayer = 'bot'; // тем самым блокирую нажатия и наведение на клетку\n  GamePlay.showMessage('Вражеские герои повержены!');\n  reloadState(state);\n  window.location.reload();\n}\n","import GamePlay from '../Services/GamePlay';\nimport { winGame } from './gameOver';\n\n/* eslint-disable no-param-reassign */\nexport default function checkHealth(state, gameController) {\n  const { botTeam } = state.team;\n  const { playerTeam } = state.team;\n\n  playerTeam.forEach((obj, index) => {\n    if (obj.character.health <= 0) {\n      playerTeam.splice(index, 1);\n    }\n  });\n  botTeam.forEach((obj, index) => {\n    if (obj.character.health <= 0) {\n      botTeam.splice(index, 1);\n    }\n  });\n  if (!botTeam.length) {\n    if (state.currentLevel === 4) {\n      GamePlay.showMessage('Победа!');\n      winGame(state);\n    }\n    state.currentLevel += 1;\n    state.maxLevelChar += 1;\n    gameController.render(\n      state.levels[state.currentLevel],\n      state.maxLevelChar,\n      state.maxCharsCount,\n      gameController.playerAllowedChars,\n      gameController.botAllowedChars,\n    );\n    state.team.playerTeam.forEach((obj) => {\n      obj.character.levelUp();\n    });\n  }\n}\n","/* eslint-disable no-param-reassign */\n/* eslint-disable max-len */\n\n/**\n * Функция определяет атаку персонажа бота\n * Параметры функции:\n * @param state принимает текущее состояние игры\n * @param gamePlay принимает текущее свойство gamePlay\n * @param gameController принимает текущее свойство gameController\n * @param playerTeam массив из инстансов класса PositionedCharacter (character, position), т.е текущая команда игрока\n * @param botTeam массив из инстансов класса PositionedCharacter (character, position), т.е текущая команда бота\n * @param attackersArr массив из персонажей бота, которые могут атаковать в данный момент\n */\n\nimport GamePlay from '../Services/GamePlay';\nimport checkActivePlayer from './checkActivePlayer';\nimport checkHealth from './checkHealth';\n\nexport function attackWithSeveral(state, gamePlay, gameController, playerTeam, botTeam, attackersArr) {\n  const randomIndex = Math.floor(Math.random() * attackersArr.length);\n  const targetCell = attackersArr[randomIndex].cellForAction;\n  const targetObj = playerTeam.find((char) => char.position === targetCell);\n  const attackerObj = botTeam.find((char) => char.position === attackersArr[randomIndex].currentCell);\n  const damage = Math.max(attackerObj.character.attack - targetObj.character.defence, attackerObj.character.attack * 0.1);\n  gamePlay.showDamage(targetObj.position, damage).then(() => {\n    state.team.playerTeam.forEach((obj) => {\n      if (obj.position === targetObj.position) {\n        obj.character.health -= damage;\n        Number(obj.character.health.toFixed(1));\n        checkHealth(state, gameController);\n      }\n    });\n    gamePlay.redrawPositions([...state.team.playerTeam, ...state.team.botTeam]);\n    state.currentPlayer = 'player';\n    GamePlay.showMessage('Ход игрока');\n    checkActivePlayer(state, gameController, gamePlay);\n  });\n}\n\nexport function attackWithSingle(state, gamePlay, gameController, playerTeam, botTeam, attackersArr) {\n  const targetCell = attackersArr[0].cellForAction;\n  const targetObj = playerTeam.find((char) => char.position === targetCell);\n  const attackerObj = botTeam.find((char) => char.position === attackersArr[0].currentCell);\n  const damage = Math.max(attackerObj.character.attack - targetObj.character.defence, attackerObj.character.attack * 0.1);\n  gamePlay.showDamage(targetObj.position, damage).then(() => {\n    state.team.playerTeam.forEach((obj) => {\n      if (obj.position === targetObj.position) {\n        obj.character.health -= damage;\n        Number(obj.character.health.toFixed(1));\n        checkHealth(state, gameController);\n      }\n    });\n    gamePlay.redrawPositions([...state.team.playerTeam, ...state.team.botTeam]);\n    state.currentPlayer = 'player';\n    checkActivePlayer(state, gameController, gamePlay);\n  });\n}\n","/* eslint-disable max-len */\n/**\n * Функция определяет клетку для движения персонажа бота\n * Клетка выбирается на основании позиции персонажа игрока (бот подбирается настолько близко, насколько возможно для атаки)\n * Клетка записывается в info.cellForAction\n * @param botCharacter принимает инстанс класса Positioned Character со свойством character (botTeam[i].character)\n * @param playerTeam принимает массив инстансов класса Positioned Character со свойством character (playerTeamTeam[i] (свойства character и position));\n * @param currentBotCell текущая позиция персонажа бота\n * @param gamePlay свойство this.gamePlay\n * @param gameState свойство this.state\n * @returns void. Клетка для действия записывается в info.cellForAction\n */\n\nexport default function calculateCellforAction(botCharacter, playerTeam, gamePlay, gameState) {\n  let resHorizontal = Infinity;\n  let resVertical = Infinity;\n  let cellForMove; // клетка для передвижения\n  for (let i = 0; i < botCharacter.moveCells.length; i += 1) {\n    const cell = botCharacter.moveCells[i];\n    const cellAxisHorizontal = cell % gamePlay.boardSize;\n    const cellAxisVertical = Math.floor(cell / gamePlay.boardSize);\n\n    for (let j = 0; j < playerTeam.length; j += 1) {\n      const playerHorizontal = playerTeam[j].character.axisHorizontal;\n      const playerVertical = playerTeam[j].character.axisVertical;\n      const { type } = botCharacter;\n\n      const radiusAttack = gameState.allowedForAttack[type];\n\n      const tempDiffHorizontal = Math.abs(cellAxisHorizontal - playerHorizontal);\n      const tempDiffVertical = Math.abs(cellAxisVertical - playerVertical);\n\n      let tempResHorizontal = tempDiffHorizontal - radiusAttack;\n      if (tempResHorizontal < 0) tempResHorizontal = 0;\n      let tempResVertical = tempDiffVertical - radiusAttack;\n      if (tempResVertical < 0) tempResVertical = 0;\n\n      if (tempResHorizontal <= resHorizontal && tempResVertical <= resVertical) {\n        resHorizontal = tempResHorizontal;\n        resVertical = tempResVertical;\n        cellForMove = cell;\n      }\n      if (tempResHorizontal > resHorizontal || tempResVertical > resVertical) {\n        const tempSum = tempResHorizontal + tempResVertical;\n        const resSum = resHorizontal + resVertical;\n        if (tempSum <= resSum) {\n          resHorizontal = tempResHorizontal;\n          resVertical = tempResVertical;\n          cellForMove = cell;\n        }\n      }\n    }\n  }\n  return cellForMove;\n}\n","/* eslint-disable no-param-reassign */\nimport checkActivePlayer from './checkActivePlayer';\n\nexport function moveWithSeveral(state, gamePlay, gameController, botTeam, moversArr) {\n  const randomIndex = Math.floor(Math.random() * moversArr.length);\n  const targetCell = moversArr[randomIndex].cellForAction;\n  const moverObj = botTeam.find((char) => char.position === moversArr[randomIndex].currentCell);\n  state.team.botTeam.forEach((obj) => {\n    if (obj.position === moverObj.position) {\n      obj.position = targetCell;\n    }\n  });\n  gamePlay.redrawPositions([...state.team.playerTeam, ...state.team.botTeam]);\n  state.currentPlayer = 'player';\n  checkActivePlayer(state, gameController, gamePlay);\n}\n\nexport function moveWithSingle(state, gamePlay, gameController, botTeam, moversArr) {\n  const targetCell = moversArr[0].cellForAction;\n  const moverObj = botTeam.find((char) => char.position === moversArr[0].currentCell);\n  state.team.botTeam.forEach((obj) => {\n    if (obj.position === moverObj.position) {\n      obj.position = targetCell;\n    }\n  });\n  gamePlay.redrawPositions([...state.team.playerTeam, ...state.team.botTeam]);\n  state.currentPlayer = 'player';\n  checkActivePlayer(state, gameController, gamePlay);\n}\n","/* eslint-disable no-console */\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-len */\nimport { attackWithSeveral, attackWithSingle } from '../Modules/botAttack';\n\nimport calculateCellsForAttack from '../Modules/calculateCellsForAttack';\nimport calculateCellsForMove from '../Modules/calculateCellsForMove';\nimport calculateCellForAction from '../Modules/calculateCellForAction';\n\nimport { moveWithSeveral, moveWithSingle } from '../Modules/botMove';\n\n/**\n * Класс определяет поведение персонажа бота\n * Параметры конструктора класса:\n * @param playerTeam принимает массив из инстансов класса Positioned Character из this.state.team.playerTeam\n * @param botTeam принимает массив из инстансов класса Positioned Character из this.state.team.botTeam\n * @param leftBorder массив из индексов левой границы поля\n * @param rightBorder массив из индексов правой границы поля\n * @param gameState текущий инстанс класса GameState\n * @param gamePlay текущий инстанс класса GamePlay\n * @param gameController текущий инстанс класса GameController\n */\n\nexport default class BotActionLogic {\n  constructor(playerTeam, botTeam, leftBorder, rightBorder, gameState, gamePlay, gameController) {\n    this.playerTeam = playerTeam;\n    this.playerPositions = [];\n    this.botPositions = [];\n    this.botTeam = botTeam;\n    this.leftBorder = leftBorder;\n    this.rightBorder = rightBorder;\n    this.state = gameState;\n    this.gamePlay = gamePlay;\n    this.gameController = gameController;\n    this.arrOfAttackers = []; // массив с персонажами бота, которые могут атаковать\n    this.arrOfMovers = []; // массив с персонажами бота, которые могут ходить\n  }\n\n  /**\n * Метод работает с позициями персонажей\n */\n  calculatePositions() {\n    // В свойство playerPositions пушим текущие позиции персонажей игрока, для удобства работы с ними внутри метода\n    this.playerTeam.forEach((obj) => {\n      this.playerPositions.push(obj.position);\n    });\n    this.botTeam.forEach((obj) => {\n      const allowedSteps = this.state.allowedSteps[obj.character.type]; // радиус движение\n      const allowedForAttack = this.state.allowedForAttack[obj.character.type]; // радиус атаки\n      // в соответствующие свойства каждого персонажа бота записываем индексы клеток и добавляем свойство info\n      obj.character.moveCells = calculateCellsForMove(this.gamePlay, this.state, obj.position, allowedSteps, this.leftBorder, this.rightBorder);\n      obj.character.attackCells = calculateCellsForAttack(this.gamePlay, obj.position, allowedForAttack);\n      obj.character.info = [];\n      this.gamePlay.deselectCell(obj.position);\n      this.botPositions.push(obj.position);\n    });\n  }\n  /**\n * Метод работает с позициями персонажей и добавляет их в сооветствеющие свойства\n */\n\n  addPositionsToProps() {\n    this.playerPositions.forEach((position) => {\n      const playerObj = this.playerTeam.find((obj) => obj.position === position);\n      playerObj.character.axisHorizontal = position % this.gamePlay.boardSize; // считаем горизонтальную ось и записываем в соответствующее свойство\n      playerObj.character.axisVertical = Math.floor(position / this.gamePlay.boardSize); // считаем вертикальную ось и записываем в соответствующее свойство\n\n      for (let i = 0; i < this.botTeam.length; i += 1) {\n        const toInfo = { action: null, cellForAction: null }; // формируем объект для дальнейшего пуша в свойство info\n        this.botTeam[i].character.axisHorizontal = this.botTeam[i].position % this.gamePlay.boardSize; // // считаем горизонтальную ось и записываем в соответствующее свойство\n        this.botTeam[i].character.axisVertical = Math.floor(this.botTeam[i].position / this.gamePlay.boardSize); // // считаем вертикальную ось и записываем в соответствующее свойство\n        // если есть клетки для атаки\n        if (this.botTeam[i].character.attackCells.includes(position)) {\n          toInfo.action = 'attack';\n          toInfo.cellForAction = position;\n          toInfo.currentCell = this.botTeam[i].position;\n          toInfo.currentType = this.botTeam[i].character.type;\n        }\n        // если клеток для атаки нет\n        if (!this.botTeam[i].character.attackCells.includes(position)) {\n          toInfo.action = 'move';\n          toInfo.currentCell = this.botTeam[i].position;\n          toInfo.currentType = this.botTeam[i].character.type;\n          // определяем клетку оптимальную клетку для движения с помощью функции calculateCellforAction\n          toInfo.cellForAction = calculateCellForAction(this.botTeam[i].character, this.playerTeam, this.gamePlay, this.state);\n        }\n        this.botTeam[i].character.info.push(toInfo);\n      }\n    });\n  }\n\n  checkForAttack() {\n    const attackers = [];\n    this.botTeam.forEach((char) => {\n      const findedAttacker = char.character.info.find((obj) => obj.action === 'attack');\n      if (findedAttacker) attackers.push(findedAttacker);\n    });\n    attackers.forEach((obj) => this.arrOfAttackers.push(obj));\n    return !!this.arrOfAttackers.length;\n  }\n\n  checkForMove() {\n    const movers = [];\n    this.botTeam.forEach((char) => {\n      const findedMover = char.character.info.find((obj) => obj.action === 'move');\n      if (findedMover) movers.push(findedMover);\n    });\n    movers.forEach((obj) => this.arrOfMovers.push(obj));\n    return !!this.arrOfMovers.length;\n  }\n\n  attack() {\n    const undeadAttackers = this.arrOfAttackers.filter((obj) => obj.currentType === 'undead');\n    const vampireAttackers = this.arrOfAttackers.filter((obj) => obj.currentType === 'vampire');\n    const daemonAttackers = this.arrOfAttackers.filter((obj) => obj.currentType === 'daemon');\n\n    console.log('АТАКА!!!');\n    console.log('Те, кто атакуют: ', this.arrOfAttackers);\n    console.log(undeadAttackers, vampireAttackers, daemonAttackers);\n\n    // начинаем проверять массив с атакующими персонажами с андедов и т.д.\n    // если андедов больше 1, тогда используем функцию, которая определит каким атаковать\n    if (undeadAttackers.length > 1) {\n      attackWithSeveral(this.state, this.gamePlay, this.gameController, this.playerTeam, this.botTeam, undeadAttackers);\n    }\n    // если андед 1, тогда он атакует\n    if (undeadAttackers.length === 1) {\n      attackWithSingle(this.state, this.gamePlay, this.gameController, this.playerTeam, this.botTeam, undeadAttackers);\n      return;\n    }\n\n    if (vampireAttackers.length > 1) {\n      attackWithSeveral(this.state, this.gamePlay, this.gameController, this.playerTeam, this.botTeam, vampireAttackers);\n    }\n    if (vampireAttackers.length === 1) {\n      attackWithSingle(this.state, this.gamePlay, this.gameController, this.playerTeam, this.botTeam, vampireAttackers);\n    }\n\n    if (daemonAttackers.length > 1) {\n      attackWithSeveral(this.state, this.gamePlay, this.gameController, this.playerTeam, this.botTeam, daemonAttackers);\n    }\n    if (daemonAttackers.length === 1) {\n      attackWithSingle(this.state, this.gamePlay, this.gameController, this.playerTeam, this.botTeam, daemonAttackers);\n    }\n  }\n\n  move() {\n    const undeadMovers = this.arrOfMovers.filter((obj) => obj.currentType === 'undead');\n    const vampireMovers = this.arrOfMovers.filter((obj) => obj.currentType === 'vampire');\n    const daemonMovers = this.arrOfMovers.filter((obj) => obj.currentType === 'daemon');\n\n    console.log('ХОДИМ!!!');\n    console.log('Те, кто ходят: ', this.arrOfMovers);\n    console.log(undeadMovers, vampireMovers, daemonMovers);\n\n    if (undeadMovers.length === 1) {\n      moveWithSingle(this.state, this.gamePlay, this.gameController, this.botTeam, undeadMovers);\n      return;\n    }\n    if (undeadMovers.length > 1) {\n      moveWithSeveral(this.state, this.gamePlay, this.gameController, this.botTeam, undeadMovers);\n    }\n\n    if (vampireMovers.length === 1) {\n      moveWithSingle(this.state, this.gamePlay, this.gameController, this.botTeam, vampireMovers);\n      return;\n    }\n    if (vampireMovers.length > 1) {\n      moveWithSeveral(this.state, this.gamePlay, this.gameController, this.botTeam, vampireMovers);\n    }\n\n    if (daemonMovers.length === 1) {\n      moveWithSingle(this.state, this.gamePlay, this.gameController, this.botTeam, daemonMovers);\n      return;\n    }\n    if (daemonMovers.length > 1) {\n      moveWithSeveral(this.state, this.gamePlay, this.gameController, this.botTeam, daemonMovers);\n    }\n  }\n}\n","export default class GameStateService {\n  constructor(storage) {\n    this.storage = storage;\n  }\n\n  save(state) {\n    this.storage.setItem('state', JSON.stringify(state));\n  }\n\n  load() {\n    try {\n      return JSON.parse(this.storage.getItem('state'));\n    } catch (e) {\n      throw new Error('Invalid state');\n    }\n  }\n}\n","import Character from './Character';\n\nexport default class CharacterLoaded extends Character {\n  constructor(object, level) {\n    super(level);\n    this.level = level;\n    this.type = object.type;\n    this.attack = object.attack;\n    this.defence = object.defence;\n    this.health = object.health;\n    this.axisHorizontal = object.axisHorizontal;\n    this.axisVertical = object.axisVertical;\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport Character from './Character';\n\nexport default class Bowman extends Character {\n  constructor(level, type = 'bowman') {\n    if (type !== 'bowman') {\n      throw new Error('Invalid type for bowman');\n    }\n    super(level, type);\n    this.attack = 25;\n    this.defence = 25;\n  }\n\n  get _type() {\n    return this.type;\n  }\n\n  set _type(value) {\n    if (value !== 'bowman') {\n      throw new Error('Invalid type for bowman');\n    }\n    this.type = value;\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport Character from './Character';\n\nexport default class Magician extends Character {\n  constructor(level, type = 'magician') {\n    if (type !== 'magician') {\n      throw new Error('Invalid type for magician');\n    }\n    super(level, type);\n    this.attack = 10;\n    this.defence = 40;\n  }\n\n  get _type() {\n    return this.type;\n  }\n\n  set _type(value) {\n    if (value !== 'magician') {\n      throw new Error('Invalid type for magician');\n    }\n    this.type = value;\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport Character from './Character';\n\nexport default class Swordsman extends Character {\n  constructor(level, type = 'swordsman') {\n    if (type !== 'swordsman') {\n      throw new Error('Invalid type for swordsman');\n    }\n    super(level, type);\n    this.attack = 40;\n    this.defence = 10;\n  }\n\n  get _type() {\n    return this.type;\n  }\n\n  set _type(value) {\n    if (value !== 'swordsman') {\n      throw new Error('Invalid type for swordsman');\n    }\n    this.type = value;\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport Character from './Character';\n\nexport default class Undead extends Character {\n  constructor(level, type = 'undead') {\n    if (type !== 'undead') {\n      throw new Error('Invalid type for undead');\n    }\n    super(level, type);\n    this.attack = 40;\n    this.defence = 10;\n  }\n\n  get _type() {\n    return this.type;\n  }\n\n  set _type(value) {\n    if (value !== 'undead') {\n      throw new Error('Invalid type for undead');\n    }\n    this.type = value;\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport Character from './Character';\n\nexport default class Vampire extends Character {\n  constructor(level, type = 'vampire') {\n    if (type !== 'vampire') {\n      throw new Error('Invalid type for vampire');\n    }\n    super(level, type);\n    this.attack = 25;\n    this.defence = 25;\n  }\n\n  get _type() {\n    return this.type;\n  }\n\n  set _type(value) {\n    if (value !== 'vampire') {\n      throw new Error('Invalid type for vampire');\n    }\n    this.type = value;\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport Character from './Character';\n\nexport default class Daemon extends Character {\n  constructor(level, type = 'daemon') {\n    if (type !== 'daemon') {\n      throw new Error('Invalid type for daemon');\n    }\n    super(level, type);\n    this.attack = 10;\n    this.defence = 10;\n  }\n\n  get _type() {\n    return this.type;\n  }\n\n  set _type(value) {\n    if (value !== 'daemon') {\n      throw new Error('Invalid type for daemon');\n    }\n    this.type = value;\n  }\n}\n","/**\n * Entry point of app: don't change this\n */\nimport GamePlay from './Services/GamePlay';\nimport GameController from './Services/GameController';\nimport GameStateService from './Services/GameStateService';\n\nconst gamePlay = new GamePlay();\ngamePlay.bindToDOM(document.querySelector('#game-container'));\n\nconst stateService = new GameStateService(localStorage);\n\nconst gameCtrl = new GameController(gamePlay, stateService);\ngameCtrl.init();\n\n// don't write your code here\n","/* eslint-disable no-console */\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-len */\nimport GamePlay from './GamePlay';\nimport GameState from '../Modules/GameState';\nimport { generatePosition, generatePositionedCharacter } from '../Modules/generators';\nimport cursors from '../Modules/cursors';\nimport calculateCellsForMove from '../Modules/calculateCellsForMove';\nimport calculateCellsForAttack from '../Modules/calculateCellsForAttack';\nimport BotActionLogic from './BotActionLogic';\nimport checkActivePlayer from '../Modules/checkActivePlayer';\nimport checkHealth from '../Modules/checkHealth';\nimport reloadState from '../Modules/reloadState';\nimport GameStateService from './GameStateService';\nimport PositionedCharacter from '../Modules/PositionedCharacter';\nimport CharacterLoaded from '../characters/CharacterLoaded';\nimport Bowman from '../characters/Bowman';\nimport Magician from '../characters/Magician';\nimport Swordsman from '../characters/Swordsman';\nimport Undead from '../characters/Undead';\nimport Vampire from '../characters/Vampire';\nimport Daemon from '../characters/Daemon';\n\nexport default class GameController {\n  constructor(gamePlay, stateService) {\n    this.gamePlay = gamePlay;\n    this.stateService = stateService;\n    this.state = new GameState();\n    this.gameStateService = new GameStateService(localStorage);\n    this.playerAllowedChars = [Bowman, Magician, Swordsman];\n    this.botAllowedChars = [Undead, Vampire, Daemon];\n  }\n\n  init() {\n    // TODO: add event listeners to gamePlay events\n    // TODO: load saved stated from stateService\n\n    // Задача #1.1 - Отрисовываем поле\n    this.render(\n      this.state.levels[this.state.currentLevel],\n      this.state.maxLevelChar,\n      this.state.maxCharsCount,\n      this.playerAllowedChars,\n      this.botAllowedChars,\n    );\n    this.addListenerFuncs();\n    console.log(this.state);\n  }\n\n  render(level, maxLevelChar, characterCount, playerAllowedChars, botTeamAllowedChars) {\n    let playerRender = null;\n    if (this.state.currentLevel === 1) {\n      playerRender = generatePositionedCharacter('player', playerAllowedChars, maxLevelChar, characterCount);\n    } else {\n      const currentRandomPositions = []; // массив рандомных позиций, чтобы исключить повторы\n      playerRender = this.state.team.playerTeam;\n      this.state.team.playerTeam.forEach((obj) => {\n        const position = generatePosition('player');\n        if (!currentRandomPositions.includes(position)) {\n          currentRandomPositions.push(position);\n          obj.position = position;\n        }\n      });\n    }\n    this.gamePlay.drawUi(level);\n    const botRender = generatePositionedCharacter('bot', botTeamAllowedChars, maxLevelChar, characterCount);\n    this.state.team.playerTeam = [...playerRender];\n    this.state.team.botTeam = [...botRender];\n    this.gamePlay.redrawPositions([...playerRender, ...botRender]);\n    this.calculateFieldBorders(this.gamePlay.boardSize);\n  }\n\n  /**\n * Метод определяет поведение персонажа бота\n * Выбирается ячейка для бота, в зависимости от возможности - он либо идет, либо атакует\n * Атака:\n * - если есть возможность, то персонаж всегда атакует\n * - при возможности атаки у нескольких персонажей - атакуют в таком порядке (undead, vampire, daemon)\n * У undead сильнее всех атака, соответственно атакует в первую очередь он.\n * Движение:\n * - движение происходит в таком порядке (undead, vampire, daemon)\n * Так как у undead сильнее всего атака, ему нужно как можно скорее сблизиться для атаки\n *\n * После действия меняется ход\n * @param botTeam принимает массив из инстансов класса Positioned Character из this.state.team.botTeam\n * this.state.team.botTeam = [PositionedCharacter, PositionedCharacter] -----> PositionedCharacter = {character: Vampire{...}, position: 22}\n * @returns возвращает действие и переключает активного игрока\n */\n  botAction(botTeam) {\n    const botLogic = new BotActionLogic(this.state.team.playerTeam, botTeam, this.state.borders.left, this.state.borders.right, this.state, this.gamePlay, this);\n    botLogic.calculatePositions();\n    botLogic.addPositionsToProps();\n    const isAttack = botLogic.checkForAttack();\n\n    if (isAttack) {\n      botLogic.attack();\n    }\n    if (!isAttack) {\n      botLogic.checkForMove();\n      botLogic.move();\n    }\n  }\n\n  onCellClick(index) {\n    if (this.state.currentPlayer !== 'player') {\n      return;\n    }\n    const findedChar = this.findChar(index);\n    if (findedChar) {\n      const isUserCharacter = this.state.isUserCharacter(findedChar);\n      console.log(isUserCharacter);\n      if (isUserCharacter) {\n        this.state.selectChar(this.gamePlay, this.state, index, findedChar.type, findedChar.team);\n        return;\n      }\n      if (this.state.selected.isSelected && !isUserCharacter) {\n        this.playerAttack(index);\n        return;\n      }\n      GamePlay.showMessage('Выбран персонаж противника');\n      return;\n    }\n    if (this.state.selected.isSelected) {\n      this.playerMove();\n      return;\n    }\n    GamePlay.showMessage('Выбрана пустая ячейка');\n  }\n\n  onCellEnter(index) {\n    const finded = this.findChar(index); // ищем в ячейке персонажа\n    if (finded) {\n      const {\n        level, attack, defence, health,\n      } = finded;\n      const message = `${String.fromCodePoint(0x0001F396)}${level} ${String.fromCodePoint(0x00002694)}${attack} ${String.fromCodePoint(0x0001F6E1)}${defence} ${String.fromCodePoint(0x00002764)}${health}`;\n      this.gamePlay.showCellTooltip(message, index);\n    }\n    if (this.state.currentPlayer === 'bot') {\n      return;\n    }\n    this.cellEnterFunc(index);\n  }\n\n  onCellLeave(index) {\n    this.gamePlay.hideCellTooltip(index);\n    if (!this.state.selected.isSelected) { // если нет выбранного персонажа\n      this.gamePlay.setCursor(cursors.auto);\n    }\n    if (this.state.mouseEnter.move != null) { // если навели на клетку, и она доступна для движения\n      this.gamePlay.deselectCell(this.state.mouseEnter.move);\n    }\n    if (this.state.mouseEnter.attack != null) { // если навели на клетку, и она доступна для атаки\n      this.gamePlay.deselectCell(this.state.mouseEnter.attack);\n    }\n    this.state.mouseEnter.move = null;\n    this.state.mouseEnter.attack = null;\n  }\n\n  addListenerFuncs() {\n    this.gamePlay.addCellEnterListener(this.onCellEnter.bind(this));\n    this.gamePlay.addCellLeaveListener(this.onCellLeave.bind(this));\n    this.gamePlay.addCellClickListener(this.onCellClick.bind(this));\n\n    this.gamePlay.addNewGameListener(this.onNewGameClick.bind(this));\n    this.gamePlay.addSaveGameListener(this.onSaveGameClick.bind(this));\n    this.gamePlay.addLoadGameListener(this.onLoadGameClick.bind(this));\n  }\n\n  onNewGameClick() {\n    localStorage.clear();\n    reloadState(this.state);\n    this.render(\n      this.state.levels[this.state.currentLevel],\n      this.state.maxLevelChar,\n      this.state.maxCharsCount,\n      this.playerAllowedChars,\n      this.botAllowedChars,\n    );\n  }\n\n  onSaveGameClick() {\n    GamePlay.showMessage('Данные успешно сохранены!');\n    localStorage.clear();\n    this.gameStateService.save(this.state);\n  }\n\n  onLoadGameClick() {\n    if (!localStorage.getItem('state')) {\n      GamePlay.showMessage('Сохранения не найдены!');\n      return;\n    }\n    GamePlay.showMessage('Игра успешно загружена!');\n    const state = this.gameStateService.load();\n    console.log('before', state, this.state);\n\n    state.team.playerTeam.map((obj) => {\n      obj.character = new CharacterLoaded(obj.character, obj.character.level);\n      obj = new PositionedCharacter(obj.character, obj.position);\n      return obj;\n    });\n    state.team.botTeam.map((obj) => {\n      obj.character = new CharacterLoaded(obj.character, obj.character.level);\n      obj = new PositionedCharacter(obj.character, obj.position);\n      return obj;\n    });\n\n    this.state.selected = state.selected;\n    this.state.team = state.team;\n    this.state.currentLevel = state.currentLevel;\n\n    this.gamePlay.drawUi(this.state.levels[this.state.currentLevel]);\n    this.gamePlay.redrawPositions([...this.state.team.playerTeam, ...this.state.team.botTeam]);\n    console.log('after', state, this.state);\n  }\n\n  /**\n * Функция ищет инстанс класса одного из персонажей среди сгенерированных по индексу\n * @param index индекс клетки, на которой может быть персонаж\n * @returns возвращает инстанс класса одного из персонажей на клетке\n */\n\n  findChar(index) {\n    let res;\n    const values = [...this.state.team.playerTeam, ...this.state.team.botTeam];\n    values.forEach((char) => {\n      if (char.position === index) {\n        if (this.state.team.playerTypes.includes(char.character.type)) {\n          char.character.team = 'player';\n        }\n        res = char.character;\n      }\n    });\n    return res;\n  }\n\n  /**\n * Функция проверяет клетку на возможность действия (атака/движение)\n * @param action действие, на которое проверяем - 'attack' или 'move'\n * @param currentIndex индекс клетки, которую проверяем по отношению к выбранному персонажу\n * @returns возвращает булево значение\n */\n  checkAreaForActions(action, currentIndex) {\n    const selectedChar = this.findChar(this.state.selected.position);\n    const { position: selectedCharIndex } = this.state.selected;\n    const { type } = selectedChar;\n    if (action === 'move') {\n      const allowedSteps = this.state.allowedSteps[type];\n      const cellsForMoving = calculateCellsForMove(this.gamePlay, this.state, selectedCharIndex, allowedSteps, this.state.borders.left, this.state.borders.right);\n      if (cellsForMoving.includes(currentIndex)) {\n        return true;\n      }\n    }\n    if (action === 'attack') {\n      const allowedForAttack = this.state.allowedForAttack[type];\n      const cellsForAttack = calculateCellsForAttack(this.gamePlay, selectedCharIndex, allowedForAttack);\n      if (cellsForAttack.includes(currentIndex)) {\n        return true;\n      }\n      console.log('CELLS FOR ATTACK', cellsForAttack);\n    }\n    return false;\n  }\n\n  /**\n * Рассчитываем индексы левой и правой границ поля\n  сохраняем в инстанс GameState в свойство borders\n * @param rowSize количество рядов, соответственно boardSize, т.к. поле квадратное\n * @returns ничего не возвращает. В соответствующие свойства пушатся результаты.\n */\n  calculateFieldBorders(rowSize) {\n    for (let i = 0; i < rowSize ** 2; i += rowSize) {\n      this.state.borders.left.push(i);\n      this.state.borders.right.push(i + (rowSize - 1));\n    }\n  }\n\n  playerAttack(index) {\n    const isAllowedForAttack = this.state.mouseEnter.attack; // смотрим записан ли в this.state.mouseEnter.attack индекс\n    const currentChar = this.findChar(this.state.selected.position); // находим текущего активного персонажа\n    if (isAllowedForAttack != null) {\n      const botChar = this.findChar(index);\n      const damage = Math.max(currentChar.attack - botChar.defence, currentChar.attack * 0.1);\n      this.gamePlay.showDamage(index, damage).then(() => {\n        this.state.team.botTeam.forEach((obj) => {\n          if (obj.position === index) {\n            obj.character.health -= damage;\n            Number(obj.character.health.toFixed(1));\n            checkHealth(this.state, this);\n          }\n        });\n        this.gamePlay.redrawPositions([...this.state.team.playerTeam, ...this.state.team.botTeam]);\n        this.gamePlay.deselectCell(this.state.selected.position);\n        console.log(this.state);\n        this.state.currentPlayer = 'bot';\n        checkActivePlayer(this.state, this, this.gamePlay);\n      });\n    }\n  }\n\n  playerMove() {\n    const isAllowedForMove = this.state.mouseEnter.move;\n    if (isAllowedForMove != null) {\n      this.state.team.playerTeam.forEach((char) => {\n        if (char.position === this.state.selected.position) {\n          char.position = this.state.mouseEnter.move;\n          this.gamePlay.deselectCell(this.state.selected.position);\n          this.state.selected.position = this.state.mouseEnter.move;\n        }\n      });\n      this.gamePlay.redrawPositions([...this.state.team.playerTeam, ...this.state.team.botTeam]);\n      this.gamePlay.deselectCell(this.state.mouseEnter.move);\n      console.log('Сработало движение!!!');\n      console.log(this.state.team.playerTeam);\n      console.log(this.state.mouseEnter);\n    } else {\n      return;\n    }\n    this.state.currentPlayer = 'bot';\n    checkActivePlayer(this.state, this, this.gamePlay);\n  }\n\n  cellEnterFunc(index) {\n    const finded = this.findChar(index); // ищем в ячейке персонажа\n    const { isSelected } = this.state.selected || null; // выбран ли персонаж\n    if (finded && isSelected) {\n      const { team } = finded;\n      // если навели на персонаж игрока, то выставляем курсор\n      if (this.state.selected.charTeam === team) {\n        this.gamePlay.setCursor(cursors.pointer);\n        return;\n      }\n      // если навели на персонажа бота\n      if (this.state.selected.charTeam !== team) {\n        const isAllowedForAttack = this.checkAreaForActions('attack', index); // проверяем клетку на доступность для атаки\n        if (isAllowedForAttack) {\n          if (this.state.mouseEnter.attack !== null) {\n            this.gamePlay.deselectCell(this.state.mouseEnter.attack);\n          }\n          this.gamePlay.selectCell(index, 'red');\n          this.state.mouseEnter.attack = index;\n          this.gamePlay.setCursor(cursors.crosshair);\n          return;\n        }\n        this.gamePlay.setCursor(cursors.notallowed);\n      }\n    }\n    if (!finded && isSelected) { // если ячейка пустая, но персонаж выбран (ходим)\n      const isAllowedForMove = this.checkAreaForActions('move', index);\n      if (isAllowedForMove && this.state.mouseEnter.move === null) {\n        this.gamePlay.selectCell(index, 'green');\n        this.state.mouseEnter.move = index;\n        this.gamePlay.setCursor(cursors.pointer);\n        return;\n      }\n      if (isAllowedForMove && this.state.mouseEnter.move != null) {\n        this.gamePlay.deselectCell(this.state.mouseEnter.move);\n        this.gamePlay.selectCell(index, 'green');\n        this.state.mouseEnter.move = index;\n        this.gamePlay.setCursor(cursors.pointer);\n        return;\n      }\n      this.gamePlay.setCursor(cursors.notallowed);\n    }\n  }\n}\n"],"names":["calcTileType","index","boardSize","boardLength","row","Math","ceil","Number","isInteger","GamePlay","constructor","this","container","boardEl","cells","cellClickListeners","cellEnterListeners","cellLeaveListeners","newGameListeners","saveGameListeners","loadGameListeners","bindToDOM","HTMLElement","Error","drawUi","theme","checkBinding","innerHTML","newGameEl","querySelector","saveGameEl","loadGameEl","addEventListener","event","onNewGameClick","onSaveGameClick","onLoadGameClick","onEnterControllerBtn","classList","add","i","cellEl","document","createElement","onCellEnter","onCellLeave","onCellClick","appendChild","Array","from","children","element","style","cursor","redrawPositions","positions","cell","position","charEl","character","type","healthEl","healthIndicatorEl","health","width","addCellEnterListener","callback","push","addCellLeaveListener","addCellClickListener","addNewGameListener","addSaveGameListener","addLoadGameListener","preventDefault","indexOf","currentTarget","forEach","o","call","static","message","alert","selectCell","color","arguments","length","undefined","deselectCell","remove","filter","startsWith","showCellTooltip","title","hideCellTooltip","showDamage","damage","Promise","resolve","damageEl","textContent","removeChild","setCursor","GameState","selected","isSelected","charType","charTeam","team","playerTypes","botTypes","playerTeam","botTeam","currentLevel","currentPlayer","levels","themes","mouseEnter","attack","move","maxLevelChar","maxCharsCount","allowedSteps","swordsman","undead","bowman","vampire","magician","daemon","allowedForAttack","borders","left","right","isUserCharacter","char","includes","selectChar","gamePlay","gameState","Character","level","name","defence","_type","levelUp","attackAfter","max","defenceAfter","round","PositionedCharacter","characterGenerator","allowedTypes","maxLevel","randomCharType","floor","random","randomLevel","count","console","log","generatePosition","teamSide","generatePositionedCharacter","charsArr","characterCount","res","next","value","generateTeam","positionArr","redrawArr","isThere","calculateCellsForMove","selectedIndex","charTypeMoveNumber","leftBorder","rightBorder","occupiedCells","botCells","playerCells","obj","calculateOccupiedCells","cellsForActions","endCell","steps","moves","up","down","leftUpDiagonal","rightUpDiagonal","leftDownDiagonal","rightDownDiagonal","calculateCellsForAttack","charTypeAttackNumber","midCol","leftCol","rightCol","min","reloadState","state","checkActivePlayer","gameController","showMessage","gameOver","setTimeout","botAction","checkHealth","splice","window","location","reload","winGame","render","playerAllowedChars","botAllowedChars","attackWithSeveral","attackersArr","randomIndex","targetCell","cellForAction","targetObj","find","attackerObj","currentCell","then","toFixed","attackWithSingle","calculateCellforAction","botCharacter","cellForMove","resHorizontal","Infinity","resVertical","moveCells","cellAxisHorizontal","cellAxisVertical","j","playerHorizontal","axisHorizontal","playerVertical","axisVertical","radiusAttack","tempResHorizontal","abs","tempResVertical","moveWithSeveral","moversArr","moverObj","moveWithSingle","BotActionLogic","playerPositions","botPositions","arrOfAttackers","arrOfMovers","calculatePositions","attackCells","info","addPositionsToProps","playerObj","toInfo","action","currentType","calculateCellForAction","checkForAttack","attackers","findedAttacker","checkForMove","movers","findedMover","undeadAttackers","vampireAttackers","daemonAttackers","undeadMovers","vampireMovers","daemonMovers","GameStateService","storage","save","setItem","JSON","stringify","load","parse","getItem","e","CharacterLoaded","object","super","Bowman","Magician","Swordsman","Undead","Vampire","Daemon","stateService","localStorage","gameCtrl","gameStateService","init","addListenerFuncs","botTeamAllowedChars","playerRender","currentRandomPositions","botRender","calculateFieldBorders","botLogic","isAttack","findedChar","findChar","playerAttack","playerMove","finded","String","fromCodePoint","cellEnterFunc","cursors","bind","clear","map","checkAreaForActions","currentIndex","selectedChar","selectedCharIndex","cellsForAttack","rowSize","isAllowedForAttack","currentChar","botChar","isAllowedForMove"],"sourceRoot":""}